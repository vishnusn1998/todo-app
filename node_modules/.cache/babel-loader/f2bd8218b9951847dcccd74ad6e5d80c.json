{"ast":null,"code":"var util = require('./util');\n\nvar slice = util.slice;\nvar pluck = util.pluck;\nvar each = util.each;\nvar bind = util.bind;\nvar create = util.create;\nvar isList = util.isList;\nvar isFunction = util.isFunction;\nvar isObject = util.isObject;\nmodule.exports = {\n  createStore: createStore\n};\nvar storeAPI = {\n  version: '2.0.12',\n  enabled: false,\n  // get returns the value of the given key. If that value\n  // is undefined, it returns optionalDefaultValue instead.\n  get: function (key, optionalDefaultValue) {\n    var data = this.storage.read(this._namespacePrefix + key);\n    return this._deserialize(data, optionalDefaultValue);\n  },\n  // set will store the given value at key and returns value.\n  // Calling set with value === undefined is equivalent to calling remove.\n  set: function (key, value) {\n    if (value === undefined) {\n      return this.remove(key);\n    }\n\n    this.storage.write(this._namespacePrefix + key, this._serialize(value));\n    return value;\n  },\n  // remove deletes the key and value stored at the given key.\n  remove: function (key) {\n    this.storage.remove(this._namespacePrefix + key);\n  },\n  // each will call the given callback once for each key-value pair\n  // in this store.\n  each: function (callback) {\n    var self = this;\n    this.storage.each(function (val, namespacedKey) {\n      callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''));\n    });\n  },\n  // clearAll will remove all the stored key-value pairs in this store.\n  clearAll: function () {\n    this.storage.clearAll();\n  },\n  // additional functionality that can't live in plugins\n  // ---------------------------------------------------\n  // hasNamespace returns true if this store instance has the given namespace.\n  hasNamespace: function (namespace) {\n    return this._namespacePrefix == '__storejs_' + namespace + '_';\n  },\n  // createStore creates a store.js instance with the first\n  // functioning storage in the list of storage candidates,\n  // and applies the the given mixins to the instance.\n  createStore: function () {\n    return createStore.apply(this, arguments);\n  },\n  addPlugin: function (plugin) {\n    this._addPlugin(plugin);\n  },\n  namespace: function (namespace) {\n    return createStore(this.storage, this.plugins, namespace);\n  }\n};\n\nfunction _warn() {\n  var _console = typeof console == 'undefined' ? null : console;\n\n  if (!_console) {\n    return;\n  }\n\n  var fn = _console.warn ? _console.warn : _console.log;\n  fn.apply(_console, arguments);\n}\n\nfunction createStore(storages, plugins, namespace) {\n  if (!namespace) {\n    namespace = '';\n  }\n\n  if (storages && !isList(storages)) {\n    storages = [storages];\n  }\n\n  if (plugins && !isList(plugins)) {\n    plugins = [plugins];\n  }\n\n  var namespacePrefix = namespace ? '__storejs_' + namespace + '_' : '';\n  var namespaceRegexp = namespace ? new RegExp('^' + namespacePrefix) : null;\n  var legalNamespaces = /^[a-zA-Z0-9_\\-]*$/; // alpha-numeric + underscore and dash\n\n  if (!legalNamespaces.test(namespace)) {\n    throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes');\n  }\n\n  var _privateStoreProps = {\n    _namespacePrefix: namespacePrefix,\n    _namespaceRegexp: namespaceRegexp,\n    _testStorage: function (storage) {\n      try {\n        var testStr = '__storejs__test__';\n        storage.write(testStr, testStr);\n        var ok = storage.read(testStr) === testStr;\n        storage.remove(testStr);\n        return ok;\n      } catch (e) {\n        return false;\n      }\n    },\n    _assignPluginFnProp: function (pluginFnProp, propName) {\n      var oldFn = this[propName];\n\n      this[propName] = function pluginFn() {\n        var args = slice(arguments, 0);\n        var self = this; // super_fn calls the old function which was overwritten by\n        // this mixin.\n\n        function super_fn() {\n          if (!oldFn) {\n            return;\n          }\n\n          each(arguments, function (arg, i) {\n            args[i] = arg;\n          });\n          return oldFn.apply(self, args);\n        } // Give mixing function access to super_fn by prefixing all mixin function\n        // arguments with super_fn.\n\n\n        var newFnArgs = [super_fn].concat(args);\n        return pluginFnProp.apply(self, newFnArgs);\n      };\n    },\n    _serialize: function (obj) {\n      return JSON.stringify(obj);\n    },\n    _deserialize: function (strVal, defaultVal) {\n      if (!strVal) {\n        return defaultVal;\n      } // It is possible that a raw string value has been previously stored\n      // in a storage without using store.js, meaning it will be a raw\n      // string value instead of a JSON serialized string. By defaulting\n      // to the raw string value in case of a JSON parse error, we allow\n      // for past stored values to be forwards-compatible with store.js\n\n\n      var val = '';\n\n      try {\n        val = JSON.parse(strVal);\n      } catch (e) {\n        val = strVal;\n      }\n\n      return val !== undefined ? val : defaultVal;\n    },\n    _addStorage: function (storage) {\n      if (this.enabled) {\n        return;\n      }\n\n      if (this._testStorage(storage)) {\n        this.storage = storage;\n        this.enabled = true;\n      }\n    },\n    _addPlugin: function (plugin) {\n      var self = this; // If the plugin is an array, then add all plugins in the array.\n      // This allows for a plugin to depend on other plugins.\n\n      if (isList(plugin)) {\n        each(plugin, function (plugin) {\n          self._addPlugin(plugin);\n        });\n        return;\n      } // Keep track of all plugins we've seen so far, so that we\n      // don't add any of them twice.\n\n\n      var seenPlugin = pluck(this.plugins, function (seenPlugin) {\n        return plugin === seenPlugin;\n      });\n\n      if (seenPlugin) {\n        return;\n      }\n\n      this.plugins.push(plugin); // Check that the plugin is properly formed\n\n      if (!isFunction(plugin)) {\n        throw new Error('Plugins must be function values that return objects');\n      }\n\n      var pluginProperties = plugin.call(this);\n\n      if (!isObject(pluginProperties)) {\n        throw new Error('Plugins must return an object of function properties');\n      } // Add the plugin function properties to this store instance.\n\n\n      each(pluginProperties, function (pluginFnProp, propName) {\n        if (!isFunction(pluginFnProp)) {\n          throw new Error('Bad plugin property: ' + propName + ' from plugin ' + plugin.name + '. Plugins should only return functions.');\n        }\n\n        self._assignPluginFnProp(pluginFnProp, propName);\n      });\n    },\n    // Put deprecated properties in the private API, so as to not expose it to accidential\n    // discovery through inspection of the store object.\n    // Deprecated: addStorage\n    addStorage: function (storage) {\n      _warn('store.addStorage(storage) is deprecated. Use createStore([storages])');\n\n      this._addStorage(storage);\n    }\n  };\n  var store = create(_privateStoreProps, storeAPI, {\n    plugins: []\n  });\n  store.raw = {};\n  each(store, function (prop, propName) {\n    if (isFunction(prop)) {\n      store.raw[propName] = bind(store, prop);\n    }\n  });\n  each(storages, function (storage) {\n    store._addStorage(storage);\n  });\n  each(plugins, function (plugin) {\n    store._addPlugin(plugin);\n  });\n  return store;\n}","map":{"version":3,"sources":["E:/Todo app/todo-app/node_modules/store/src/store-engine.js"],"names":["util","require","slice","pluck","each","bind","create","isList","isFunction","isObject","module","exports","createStore","storeAPI","version","enabled","get","key","optionalDefaultValue","data","storage","read","_namespacePrefix","_deserialize","set","value","undefined","remove","write","_serialize","callback","self","val","namespacedKey","call","replace","_namespaceRegexp","clearAll","hasNamespace","namespace","apply","arguments","addPlugin","plugin","_addPlugin","plugins","_warn","_console","console","fn","warn","log","storages","namespacePrefix","namespaceRegexp","RegExp","legalNamespaces","test","Error","_privateStoreProps","_testStorage","testStr","ok","e","_assignPluginFnProp","pluginFnProp","propName","oldFn","pluginFn","args","super_fn","arg","i","newFnArgs","concat","obj","JSON","stringify","strVal","defaultVal","parse","_addStorage","seenPlugin","push","pluginProperties","name","addStorage","store","raw","prop"],"mappings":"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","sourcesContent":["var util = require('./util')\nvar slice = util.slice\nvar pluck = util.pluck\nvar each = util.each\nvar bind = util.bind\nvar create = util.create\nvar isList = util.isList\nvar isFunction = util.isFunction\nvar isObject = util.isObject\n\nmodule.exports = {\n\tcreateStore: createStore\n}\n\nvar storeAPI = {\n\tversion: '2.0.12',\n\tenabled: false,\n\t\n\t// get returns the value of the given key. If that value\n\t// is undefined, it returns optionalDefaultValue instead.\n\tget: function(key, optionalDefaultValue) {\n\t\tvar data = this.storage.read(this._namespacePrefix + key)\n\t\treturn this._deserialize(data, optionalDefaultValue)\n\t},\n\n\t// set will store the given value at key and returns value.\n\t// Calling set with value === undefined is equivalent to calling remove.\n\tset: function(key, value) {\n\t\tif (value === undefined) {\n\t\t\treturn this.remove(key)\n\t\t}\n\t\tthis.storage.write(this._namespacePrefix + key, this._serialize(value))\n\t\treturn value\n\t},\n\n\t// remove deletes the key and value stored at the given key.\n\tremove: function(key) {\n\t\tthis.storage.remove(this._namespacePrefix + key)\n\t},\n\n\t// each will call the given callback once for each key-value pair\n\t// in this store.\n\teach: function(callback) {\n\t\tvar self = this\n\t\tthis.storage.each(function(val, namespacedKey) {\n\t\t\tcallback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''))\n\t\t})\n\t},\n\n\t// clearAll will remove all the stored key-value pairs in this store.\n\tclearAll: function() {\n\t\tthis.storage.clearAll()\n\t},\n\n\t// additional functionality that can't live in plugins\n\t// ---------------------------------------------------\n\n\t// hasNamespace returns true if this store instance has the given namespace.\n\thasNamespace: function(namespace) {\n\t\treturn (this._namespacePrefix == '__storejs_'+namespace+'_')\n\t},\n\n\t// createStore creates a store.js instance with the first\n\t// functioning storage in the list of storage candidates,\n\t// and applies the the given mixins to the instance.\n\tcreateStore: function() {\n\t\treturn createStore.apply(this, arguments)\n\t},\n\t\n\taddPlugin: function(plugin) {\n\t\tthis._addPlugin(plugin)\n\t},\n\t\n\tnamespace: function(namespace) {\n\t\treturn createStore(this.storage, this.plugins, namespace)\n\t}\n}\n\nfunction _warn() {\n\tvar _console = (typeof console == 'undefined' ? null : console)\n\tif (!_console) { return }\n\tvar fn = (_console.warn ? _console.warn : _console.log)\n\tfn.apply(_console, arguments)\n}\n\nfunction createStore(storages, plugins, namespace) {\n\tif (!namespace) {\n\t\tnamespace = ''\n\t}\n\tif (storages && !isList(storages)) {\n\t\tstorages = [storages]\n\t}\n\tif (plugins && !isList(plugins)) {\n\t\tplugins = [plugins]\n\t}\n\n\tvar namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '')\n\tvar namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null)\n\tvar legalNamespaces = /^[a-zA-Z0-9_\\-]*$/ // alpha-numeric + underscore and dash\n\tif (!legalNamespaces.test(namespace)) {\n\t\tthrow new Error('store.js namespaces can only have alphanumerics + underscores and dashes')\n\t}\n\t\n\tvar _privateStoreProps = {\n\t\t_namespacePrefix: namespacePrefix,\n\t\t_namespaceRegexp: namespaceRegexp,\n\n\t\t_testStorage: function(storage) {\n\t\t\ttry {\n\t\t\t\tvar testStr = '__storejs__test__'\n\t\t\t\tstorage.write(testStr, testStr)\n\t\t\t\tvar ok = (storage.read(testStr) === testStr)\n\t\t\t\tstorage.remove(testStr)\n\t\t\t\treturn ok\n\t\t\t} catch(e) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t},\n\n\t\t_assignPluginFnProp: function(pluginFnProp, propName) {\n\t\t\tvar oldFn = this[propName]\n\t\t\tthis[propName] = function pluginFn() {\n\t\t\t\tvar args = slice(arguments, 0)\n\t\t\t\tvar self = this\n\n\t\t\t\t// super_fn calls the old function which was overwritten by\n\t\t\t\t// this mixin.\n\t\t\t\tfunction super_fn() {\n\t\t\t\t\tif (!oldFn) { return }\n\t\t\t\t\teach(arguments, function(arg, i) {\n\t\t\t\t\t\targs[i] = arg\n\t\t\t\t\t})\n\t\t\t\t\treturn oldFn.apply(self, args)\n\t\t\t\t}\n\n\t\t\t\t// Give mixing function access to super_fn by prefixing all mixin function\n\t\t\t\t// arguments with super_fn.\n\t\t\t\tvar newFnArgs = [super_fn].concat(args)\n\n\t\t\t\treturn pluginFnProp.apply(self, newFnArgs)\n\t\t\t}\n\t\t},\n\n\t\t_serialize: function(obj) {\n\t\t\treturn JSON.stringify(obj)\n\t\t},\n\n\t\t_deserialize: function(strVal, defaultVal) {\n\t\t\tif (!strVal) { return defaultVal }\n\t\t\t// It is possible that a raw string value has been previously stored\n\t\t\t// in a storage without using store.js, meaning it will be a raw\n\t\t\t// string value instead of a JSON serialized string. By defaulting\n\t\t\t// to the raw string value in case of a JSON parse error, we allow\n\t\t\t// for past stored values to be forwards-compatible with store.js\n\t\t\tvar val = ''\n\t\t\ttry { val = JSON.parse(strVal) }\n\t\t\tcatch(e) { val = strVal }\n\n\t\t\treturn (val !== undefined ? val : defaultVal)\n\t\t},\n\t\t\n\t\t_addStorage: function(storage) {\n\t\t\tif (this.enabled) { return }\n\t\t\tif (this._testStorage(storage)) {\n\t\t\t\tthis.storage = storage\n\t\t\t\tthis.enabled = true\n\t\t\t}\n\t\t},\n\n\t\t_addPlugin: function(plugin) {\n\t\t\tvar self = this\n\n\t\t\t// If the plugin is an array, then add all plugins in the array.\n\t\t\t// This allows for a plugin to depend on other plugins.\n\t\t\tif (isList(plugin)) {\n\t\t\t\teach(plugin, function(plugin) {\n\t\t\t\t\tself._addPlugin(plugin)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Keep track of all plugins we've seen so far, so that we\n\t\t\t// don't add any of them twice.\n\t\t\tvar seenPlugin = pluck(this.plugins, function(seenPlugin) {\n\t\t\t\treturn (plugin === seenPlugin)\n\t\t\t})\n\t\t\tif (seenPlugin) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tthis.plugins.push(plugin)\n\n\t\t\t// Check that the plugin is properly formed\n\t\t\tif (!isFunction(plugin)) {\n\t\t\t\tthrow new Error('Plugins must be function values that return objects')\n\t\t\t}\n\n\t\t\tvar pluginProperties = plugin.call(this)\n\t\t\tif (!isObject(pluginProperties)) {\n\t\t\t\tthrow new Error('Plugins must return an object of function properties')\n\t\t\t}\n\n\t\t\t// Add the plugin function properties to this store instance.\n\t\t\teach(pluginProperties, function(pluginFnProp, propName) {\n\t\t\t\tif (!isFunction(pluginFnProp)) {\n\t\t\t\t\tthrow new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')\n\t\t\t\t}\n\t\t\t\tself._assignPluginFnProp(pluginFnProp, propName)\n\t\t\t})\n\t\t},\n\t\t\n\t\t// Put deprecated properties in the private API, so as to not expose it to accidential\n\t\t// discovery through inspection of the store object.\n\t\t\n\t\t// Deprecated: addStorage\n\t\taddStorage: function(storage) {\n\t\t\t_warn('store.addStorage(storage) is deprecated. Use createStore([storages])')\n\t\t\tthis._addStorage(storage)\n\t\t}\n\t}\n\n\tvar store = create(_privateStoreProps, storeAPI, {\n\t\tplugins: []\n\t})\n\tstore.raw = {}\n\teach(store, function(prop, propName) {\n\t\tif (isFunction(prop)) {\n\t\t\tstore.raw[propName] = bind(store, prop)\t\t\t\n\t\t}\n\t})\n\teach(storages, function(storage) {\n\t\tstore._addStorage(storage)\n\t})\n\teach(plugins, function(plugin) {\n\t\tstore._addPlugin(plugin)\n\t})\n\treturn store\n}\n"]},"metadata":{},"sourceType":"script"}